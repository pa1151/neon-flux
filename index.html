<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Flux - Level 1</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(10, 10, 30, 0.7);
            border: 1px solid rgba(60, 60, 255, 0.5);
            border-radius: 10px;
            padding: 10px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .inventory-item {
            width: 60px;
            height: 60px;
            border-radius: 5px;
            background-color: rgba(30, 30, 60, 0.8);
            border: 2px solid rgba(80, 80, 255, 0.5);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .inventory-item:hover {
            background-color: rgba(60, 60, 120, 0.8);
            transform: translateY(-2px);
        }

        .inventory-item.selected {
            background-color: rgba(60, 120, 255, 0.6);
            border-color: rgba(200, 200, 255, 0.9);
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.7);
        }

        .inventory-item img {
            width: 32px;
            height: 32px;
            margin-bottom: 5px;
            filter: brightness(1.5);
        }

        .inventory-count {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .inventory-name {
            font-size: 10px;
            text-align: center;
        }

        #level-info {
            position: absolute;
            top: 50px;
            left: 20px;
            background-color: rgba(10, 10, 30, 0.7);
            border: 1px solid rgba(60, 60, 255, 0.5);
            border-radius: 10px;
            padding: 10px;
            z-index: 100;
            max-width: 300px;
        }

        #level-title {
            font-size: 18px;
            margin-bottom: 10px;
            color: #88f;
        }

        #level-description {
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 15px;
        }

        #level-objective {
            font-style: italic;
            font-size: 12px;
            color: #aaf;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            z-index: 1000;
        }

        #loading-progress {
            width: 300px;
            height: 10px;
            background-color: rgba(60, 60, 120, 0.5);
            border-radius: 5px;
            margin-top: 20px;
            overflow: hidden;
        }

        #loading-bar {
            height: 100%;
            width: 0%;
            background-color: rgba(100, 100, 255, 0.8);
            transition: width 0.3s ease-in-out;
        }

        #help-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(30, 30, 60, 0.7);
            color: white;
            border: 1px solid rgba(80, 80, 255, 0.5);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            z-index: 100;
        }

        #help-button:hover {
            background-color: rgba(60, 60, 120, 0.7);
        }

        #tutorial {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(100, 100, 255, 0.7);
            border-radius: 10px;
            padding: 20px;
            z-index: 1001;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
        }

        #tutorial h2 {
            color: #88f;
            margin-top: 0;
            text-align: center;
            margin-bottom: 20px;
        }

        #tutorial p {
            margin-bottom: 15px;
            line-height: 1.5;
        }

        #tutorial ul {
            margin-bottom: 20px;
            padding-left: 20px;
        }

        #tutorial li {
            margin-bottom: 10px;
        }

        #close-tutorial {
            background-color: rgba(60, 60, 255, 0.7);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
        }

        #close-tutorial:hover {
            background-color: rgba(100, 100, 255, 0.7);
        }

        #level-complete {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(100, 255, 100, 0.7);
            border-radius: 10px;
            padding: 20px;
            z-index: 1001;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            text-align: center;
        }

        #level-complete h2 {
            color: #8f8;
            margin-top: 0;
            text-align: center;
            margin-bottom: 20px;
        }

        #level-complete p {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        #next-level {
            background-color: rgba(60, 255, 60, 0.7);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
        }

        #next-level:hover {
            background-color: rgba(100, 255, 100, 0.7);
        }
    </style>
</head>

<body>
    <div id="loading">
        <div>Loading Neon Flux</div>
        <div id="loading-progress">
            <div id="loading-bar"></div>
        </div>
    </div>

    <div id="info">Neon Flux - Level 1: Connect the Circuit</div>

    <div id="level-info">
        <div id="level-title">Level 1: Connect the Circuit</div>
        <div id="level-description">Welcome to Neon Flux! In this first level, you'll learn how to build a simple
            circuit by connecting a power source to an LED.</div>
        <div id="level-objective">Objective: Connect the battery to the lamp using wires.</div>
    </div>

    <div id="inventory">
        <div class="inventory-item" data-component="wire">
            <div class="inventory-count">3</div>
            <div class="inventory-name">Wire</div>
        </div>
    </div>

    <button id="help-button">How to Play</button>

    <div id="tutorial">
        <h2>How to Play Neon Flux</h2>
        <p>Welcome to Neon Flux, a circuit building puzzle game.</p>
        <p><strong>Basic Controls:</strong></p>
        <ul>
            <li><strong>Left Click</strong> on the grid to place selected components</li>
            <li><strong>Right Click</strong> on a component to rotate it</li>
            <li><strong>Middle Click</strong> or <strong>Delete</strong> key on a component to remove it</li>
            <li>Use the <strong>Mouse Wheel</strong> to zoom in/out</li>
            <li>Hold <strong>Left Mouse Button</strong> and drag to rotate the view</li>
        </ul>
        <p><strong>Building Circuits:</strong></p>
        <ul>
            <li>Select components from your inventory at the bottom of the screen</li>
            <li>Place wires to connect power sources to components that need power</li>
            <li>Components must be directly connected to receive power</li>
            <li>Some components have specific requirements (energy type, direction, etc.)</li>
        </ul>
        <p>Complete the level by successfully powering all required components!</p>
        <button id="close-tutorial">Got it!</button>
    </div>

    <div id="level-complete">
        <h2>Level Complete!</h2>
        <p>Congratulations! You've successfully connected the circuit and powered the LED.</p>
        <p>You're ready to move on to more complex challenges!</p>
        <button id="next-level">Next Level</button>
    </div>

    <!-- Audio Element -->
    <audio id="bg-music" loop>
        <source src="./assets/audio/music/Nihilore - The Bright Lights of Summer.mp3" type="audio/mpeg">
        Your browser does not support audio.
    </audio>

    <!-- Music Controls -->
    <div class="music-controls">
        <button id="music-toggle">Play Music</button>
        <div class="volume-control">
            <label for="volume-slider">Volume:</label>
            <input type="range" id="volume-slider" min="0" max="100" value="50">
        </div>
    </div>


    <style>
        .music-controls {
            position: absolute;
            top: 70px;
            right: 20px;
            background-color: rgba(30, 30, 60, 0.8);
            color: white;
            border: 1px solid rgba(100, 100, 255, 0.7);
            padding: 10px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 100;
            box-shadow: 0 0 15px rgba(80, 80, 255, 0.5);
        }

        .music-controls button {
            background-color: rgba(60, 60, 255, 0.7);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .music-controls button:hover {
            background-color: rgba(100, 100, 255, 0.9);
            box-shadow: 0 0 10px rgba(100, 100, 255, 0.7);
        }

        .music-controls button.playing {
            background-color: rgba(255, 60, 60, 0.7);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .volume-control label {
            font-size: 14px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .volume-control input[type="range"] {
            width: 100px;
            accent-color: rgb(100, 100, 255);
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: rgba(80, 80, 255, 0.4);
            border-radius: 5px;
            outline: none;
        }

        .volume-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: rgb(100, 100, 255);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(100, 100, 255, 0.7);
        }

        .volume-control input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: rgb(100, 100, 255);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 5px rgba(100, 100, 255, 0.7);
        }
    </style>

    <script>
        // Set up audio controls after DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const bgMusic = document.getElementById('bg-music');
            const musicToggle = document.getElementById('music-toggle');
            const volumeSlider = document.getElementById('volume-slider');            

            // Set initial volume
            bgMusic.volume = volumeSlider.value / 100;

            // Play/pause toggle
            musicToggle.addEventListener('click', () => {
                if (bgMusic.paused) {
                    bgMusic.play()
                        .then(() => {
                            musicToggle.textContent = 'Pause Music';
                            musicToggle.classList.add('playing');
                        })
                        .catch(error => {
                            console.error('Error playing audio:', error);
                            alert('Could not play audio. Please check if your browser allows autoplay.');
                        });
                } else {
                    bgMusic.pause();
                    musicToggle.textContent = 'Play Music';
                    musicToggle.classList.remove('playing');
                }
            });

            // Volume control
            volumeSlider.addEventListener('input', () => {
                bgMusic.volume = volumeSlider.value / 100;
            });

            // Try to autoplay immediately, but have a fallback for browsers that block autoplay
            bgMusic.play().catch(error => {
                console.warn('Autoplay was prevented:', error);
                musicToggle.textContent = 'Play Music';
                musicToggle.classList.remove('playing');

                // Add a one-time click listener to the document to enable audio on first interaction
                document.addEventListener('click', function initAudio() {
                    if (bgMusic.paused) {
                        bgMusic.play().then(() => {
                            musicToggle.textContent = 'Pause Music';
                            musicToggle.classList.add('playing');
                        }).catch(e => console.error('Audio still failed to play:', e));
                    }
                    document.removeEventListener('click', initAudio);
                }, { once: true });
            });

            // Add visual beat synchronization if desired
            let beatSyncEnabled = true;

            // Optional: Add a simple beat visualization effect that works with any music
            if (beatSyncEnabled) {
                // Create a simple visualizer that pulses components to the beat
                const createSimpleBeatVisualizer = () => {
                    // This would be greatly simplified from your original code
                    // A basic approach could use AudioContext's AnalyserNode to detect beats
                    // For now we'll use a simple periodic pulse

                    return {
                        update: (timestamp) => {
                            // Simple pulse every 500ms (120 BPM)
                            return Math.sin(timestamp * 0.004) * 0.5 + 0.5;
                        }
                    };
                };

                const beatVisualizer = createSimpleBeatVisualizer();

                // Modify the animation loop to include beat visualization
                const originalAnimate = window.animate;
                window.animate = function () {
                    // Call original animation
                    originalAnimate();

                    // Add simple beat visualization
                    const timestamp = performance.now();
                    const beatIntensity = beatVisualizer.update(timestamp);

                    // Apply to energized components
                    if (typeof components !== 'undefined') {
                        components.forEach(component => {
                            if (component.energized) {
                                const obj = component.object3D;

                                obj.children.forEach(child => {
                                    if (child.material && child.material.emissiveIntensity) {
                                        // Add a beat-synchronized pulse
                                        child.material.emissiveIntensity = 0.5 + 0.5 * beatIntensity;
                                    }
                                });
                            }
                        });
                    }
                };
            }
        });
    </script>

    <!-- Import Three.js and required extensions -->
    <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

        // Constants for the game
        const COMPONENT_POWER_SOURCE = "power_source";
        const COMPONENT_WIRE = "wire";
        const COMPONENT_LED = "led";

        const DIRECTION_UP = 0;
        const DIRECTION_RIGHT = 1;
        const DIRECTION_DOWN = 2;
        const DIRECTION_LEFT = 3;

        const ENERGY_RED = 0;
        const ENERGY_GREEN = 1;
        const ENERGY_BLUE = 2;

        // Colors (original color set)
        const COLOR_RED_NEON = new THREE.Color(1, 0.235, 0.235);
        const COLOR_GREEN_NEON = new THREE.Color(0.235, 1, 0.235);
        const COLOR_BLUE_NEON = new THREE.Color(0.235, 0.235, 1);
        const COLOR_YELLOW_NEON = new THREE.Color(1, 1, 0.235);
        const COLOR_CYAN_NEON = new THREE.Color(0.235, 1, 1);
        const COLOR_MAGENTA_NEON = new THREE.Color(1, 0.235, 1);
        const COLOR_WHITE_NEON = new THREE.Color(0.86, 0.86, 0.86);
        
        //Brighter Color Set
        // COLOR_RED_NEON.set(1, 0.2, 0.2);
        // COLOR_GREEN_NEON.set(0.2, 1, 0.2);
        // COLOR_BLUE_NEON.set(0.2, 0.2, 1);
        // COLOR_YELLOW_NEON.set(1, 1, 0.2);
        // COLOR_CYAN_NEON.set(0.2, 1, 1);
        // COLOR_MAGENTA_NEON.set(1, 0.2, 1);
        // COLOR_WHITE_NEON.set(0.9, 0.9, 0.9);        

        const ENERGY_COLORS = {
            [ENERGY_RED]: COLOR_RED_NEON,
            [ENERGY_GREEN]: COLOR_GREEN_NEON,
            [ENERGY_BLUE]: COLOR_BLUE_NEON
        };

        const COMPONENT_COLORS = {
            [COMPONENT_POWER_SOURCE]: COLOR_YELLOW_NEON,
            [COMPONENT_WIRE]: COLOR_WHITE_NEON,
            [COMPONENT_LED]: COLOR_MAGENTA_NEON
        };

        // Grid settings
        const GRID_SIZE = 5; // 5x5 grid for first level
        const CELL_SIZE = 1; // Size of each grid cell

        const musicToggle = document.getElementById('music-toggle');
        const volumeSlider = document.getElementById('volume-slider');

        // Victory Audio Assets
        const victoryAudio = {
            winSound: new Audio('./assets/audio/sfx/power-up-type-1-230548.mp3'),
            successJingle: new Audio('./assets/audio/sfx/yay-6120.mp3')
        };

        // Set volume for audio effects
        victoryAudio.winSound.volume = 1.0;
        victoryAudio.successJingle.volume = 1.0;

        // Game state
        let scene, camera, renderer, composer;
        let controls, clock;
        let gridHelper, gridPlane;
        let selectedComponent = null;
        let hoveredCell = { x: -1, y: -1 };
        let isLevelComplete = false;
        let isComponentPlaced = false;

        // Input and Touch Support
        let raycaster, mouse; // Global raycaster and mouse

        let touchStartTime = 0; // For long press detection
        let touchStartPosition = { x: 0, y: 0 };
        let lastTouchEnd = 0;
        let isTouchMoving = false;
        let touchMode = "place"; // Default mode: "place", "rotate", "remove"
        let touchModeButton = null;

        let lastTapTime = 0; // For double-tap detection
        let longPressTimer = null; // Timer for detecting long press
        let currentTouchMode = 'place';
        let touchModeUI = null;

        // Component storage
        let components = [];
        let energyParticles = [];
        let energyPaths = [];
        let inventory = {
            [COMPONENT_WIRE]: 3
        };

        // Initialize the application
        init();

        // Main initialization function
        function init() {
            // Start loading sequence
            updateLoadingProgress(10);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            updateLoadingProgress(20);

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0.02, 0.02, 0.04);
            scene.fog = new THREE.FogExp2(0x000a0f, 0.03);

            // Create camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Set camera position based on screen size
            if (window.innerWidth <= 768) {
                // Mobile - position further back
                camera.position.set(0, 9, 9);
            } else {
                // Desktop - closer position
                camera.position.set(0, 4, 4);
            }

            camera.lookAt(0, 0, 0);

            updateLoadingProgress(30);

            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.07;
            controls.minDistance = 4;
            controls.maxDistance = 15;
            controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent camera going below grid
            controls.target.set(0, 0, 0);

            // Initialize clock for animations
            clock = new THREE.Clock();

            updateLoadingProgress(40);

            // Set up environment
            setupEnvironment();

            updateLoadingProgress(50);

            // Set up post-processing
            setupPostProcessing();

            updateLoadingProgress(60);

            // Create initial level components
            createLevelOneComponents();

            updateLoadingProgress(70);

            // Set up interactive grid
            setupInteractiveGrid();

            updateLoadingProgress(80);

            // Set up event listeners
            setupEventListeners();

            //Loading progress bar animation
            updateLoadingProgress(90);

            // Start animation loop
            animate();

            // Complete loading
            updateLoadingProgress(100);
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 500);
        }

        // Update loading progress bar
        function updateLoadingProgress(percent) {
            document.getElementById('loading-bar').style.width = `${percent}%`;
        }

        // Set up the scene environment (Original)
        // function setupEnvironment() {
        //     // Add ambient light
        //     const ambientLight = new THREE.AmbientLight(0x222233, 0.5);
        //     scene.add(ambientLight);

        //     // Add directional light for shadows
        //     const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        //     directionalLight.position.set(5, 10, 5);
        //     directionalLight.castShadow = true;
        //     scene.add(directionalLight);

        //     // Add subtle point lights for atmosphere
        //     const pointLight1 = new THREE.PointLight(0x3333ff, 1, 20);
        //     pointLight1.position.set(-8, 5, -8);
        //     scene.add(pointLight1);

        //     const pointLight2 = new THREE.PointLight(0xff3333, 1, 20);
        //     pointLight2.position.set(8, 5, 8);
        //     scene.add(pointLight2);

        //     // Create grid
        //     createGrid();

        //     // Create a background environment
        //     createBackgroundScene();
        // }
        
        // Updated lighting
        function setupEnvironment() {
            // Set darker background for better contrast
            scene.background = new THREE.Color(0.01, 0.01, 0.02);
            
            // Add ambient light - REDUCED INTENSITY
            const ambientLight = new THREE.AmbientLight(0x222233, 0.3);
            scene.add(ambientLight);

            // Add directional light for shadows - INCREASED INTENSITY
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Add subtle point lights for atmosphere - OPTIMIZED
            const pointLight1 = new THREE.PointLight(0x3333ff, 1.2, 15);
            pointLight1.position.set(-8, 5, -8);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff3333, 1.2, 15);
            pointLight2.position.set(8, 5, 8);
            scene.add(pointLight2);

            // Create grid
            createGrid();

            // Create a background environment
            createBackgroundScene();
        }
      

        // Create grid for component placement
        function createGrid() {
            // Remove any existing grid
            scene.children.forEach(obj => {
                if (obj.name === "GridHelper" || obj.name === "GridPlane" || obj.name === "GridLines") {
                    scene.remove(obj);
                }
            });

            // Create the invisible plane for grid interaction
            const gridGeometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE);
            const gridMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.0,
                side: THREE.DoubleSide
            });
            gridPlane = new THREE.Mesh(gridGeometry, gridMaterial);
            gridPlane.rotation.x = -Math.PI / 2; // Flat on XZ plane
            gridPlane.position.y = 0;
            gridPlane.name = "GridPlane";
            scene.add(gridPlane);

            // Create a darker base for the grid
            const baseGeometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a15,
                metalness: 0.8,
                roughness: 0.5,
                transparent: true,
                opacity: 0.8
            });

            const basePlane = new THREE.Mesh(baseGeometry, baseMaterial);
            basePlane.rotation.x = -Math.PI / 2; // Flat on XZ plane
            basePlane.position.y = -0.01; // Slightly below the grid lines
            basePlane.name = "GridBase";
            scene.add(basePlane);

            // Create glowing grid lines
            createGlowingGridLines();
        }

        function createGlowingGridLines() {
            // Create a group for all grid lines
            const gridLinesGroup = new THREE.Group();
            gridLinesGroup.name = "GridLines";

            // Define colors for the grid
            const primaryColor = new THREE.Color(0x00ffff); // Cyan
            const secondaryColor = new THREE.Color(0xff00ff); // Magenta

            // Create line materials with glow
            const primaryLineMaterial = new THREE.LineBasicMaterial({
                color: primaryColor,
                linewidth: 1,
                transparent: true,
                opacity: 0.8
            });

            const secondaryLineMaterial = new THREE.LineBasicMaterial({
                color: secondaryColor,
                linewidth: 1,
                transparent: true,
                opacity: 0.8
            });

            // Create a gradient effect by alternating colors
            const useSecondaryForThisLine = (i) => {
                return i % 2 === 0; // Alternating pattern
            };

            // Create grid cell outlines
            for (let i = 0; i <= GRID_SIZE; i++) {
                const lineMaterial = useSecondaryForThisLine(i) ? secondaryLineMaterial : primaryLineMaterial;

                // Horizontal lines (along X axis)
                const xLineGeometry = new THREE.BufferGeometry();
                const startX = -GRID_SIZE / 2;
                const endX = GRID_SIZE / 2;
                const z = i - GRID_SIZE / 2;

                const xLineVertices = new Float32Array([
                    startX, 0.01, z,
                    endX, 0.01, z
                ]);

                xLineGeometry.setAttribute('position', new THREE.BufferAttribute(xLineVertices, 3));
                const xLine = new THREE.Line(xLineGeometry, lineMaterial);
                gridLinesGroup.add(xLine);

                // Vertical lines (along Z axis)
                const zLineGeometry = new THREE.BufferGeometry();
                const x = i - GRID_SIZE / 2;
                const startZ = -GRID_SIZE / 2;
                const endZ = GRID_SIZE / 2;

                const zLineVertices = new Float32Array([
                    x, 0.01, startZ,
                    x, 0.01, endZ
                ]);

                zLineGeometry.setAttribute('position', new THREE.BufferAttribute(zLineVertices, 3));
                const zLine = new THREE.Line(zLineGeometry, lineMaterial);
                gridLinesGroup.add(zLine);
            }

            // Add grid lines group to scene
            scene.add(gridLinesGroup);

            // Add glow effect by duplicating lines with larger linewidth
            addGridGlowEffect(gridLinesGroup);
        }

        function addGridGlowEffect(gridLinesGroup) {
            // Clone the grid lines and add a subtle glow
            const glowGroup = gridLinesGroup.clone();
            glowGroup.name = "GridGlow";

            // Make glow slightly larger and more transparent
            glowGroup.children.forEach(line => {
                line.material = line.material.clone();
                line.material.transparent = true;
                line.material.opacity = 0.3;

                // Slight offset to avoid z-fighting
                line.position.y += 0.001;
            });

            scene.add(glowGroup);

            // Add pulsing animation to the glow
            glowGroup.userData = {
                originalOpacity: 0.3,
                pulseFactor: 0
            };

            // Add to animation loop (addPulsingGridGlowToAnimationLoop function implementation below)
            addPulsingGridGlowToAnimationLoop();
        }

        function addPulsingGridGlowToAnimationLoop() {
            // Store original animate function
            const originalAnimate = animate;

            // animate
            window.animate = function () {
                // Call original animation function first
                originalAnimate();

                // Add grid glow pulsing effect
                const glowGroup = scene.getObjectByName("GridGlow");
                if (glowGroup && glowGroup.userData) {
                    const time = Date.now() * 0.001; // Time in seconds
                    const { originalOpacity, pulseFactor } = glowGroup.userData;

                    // Create a subtle pulsing effect
                    const pulse = 0.7 + 0.3 * Math.sin(time * 0.5 + pulseFactor);

                    // Apply to all glow lines
                    glowGroup.children.forEach(line => {
                        if (line.material) {
                            line.material.opacity = originalOpacity * pulse;
                        }
                    });
                }
            };
        }

        // Create a stylized background
        function createBackgroundScene() {
            // Add a ground plane
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a15,
                metalness: 0.8,
                roughness: 0.5
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01; // Slightly below grid to avoid z-fighting
            ground.receiveShadow = true;
            scene.add(ground);

            // Create a distant cityscape
            const cityscape = new THREE.Group();
            cityscape.position.y = -0.5;

            // Create buildings with neon outlines
            for (let i = 0; i < 60; i++) {
                const height = 2 + Math.random() * 10;
                const width = 1 + Math.random() * 3;
                const depth = 1 + Math.random() * 3;

                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0a0a15,
                    metalness: 0.9,
                    roughness: 0.4
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);

                // Position buildings in a circular pattern around the scene
                const distance = 20 + Math.random() * 15;
                const angle = Math.random() * Math.PI * 2;
                building.position.set(
                    Math.cos(angle) * distance,
                    height / 2,
                    Math.sin(angle) * distance
                );

                cityscape.add(building);

                // Add neon outlines to some buildings
                if (Math.random() > 0.6) {
                    const edgesGeometry = new THREE.EdgesGeometry(buildingGeometry);
                    const color = [COLOR_RED_NEON, COLOR_BLUE_NEON, COLOR_GREEN_NEON, COLOR_CYAN_NEON, COLOR_MAGENTA_NEON][Math.floor(Math.random() * 5)];
                    const edgesMaterial = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.7
                    });
                    const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                    edges.position.copy(building.position);
                    edges.scale.set(1.01, 1.01, 1.01); // Slightly larger to avoid z-fighting
                    cityscape.add(edges);

                    // Add a point light inside some buildings for glow
                    if (Math.random() > 0.7) {
                        const light = new THREE.PointLight(color, 1, 5);
                        light.position.copy(building.position);
                        light.position.y += height / 4;
                        cityscape.add(light);
                    }
                }
            }

            scene.add(cityscape);
        }

        // Set up post-processing effects
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);

            // Standard render pass
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Unreal Bloom pass for the neon glow -
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.2,    // strength (decreased from 1.5)
                0.3,    // radius (decreased from 0.4)
                0.6     // threshold (decreased from 0.85)
            );
            composer.addPass(bloomPass);

            // Anti-aliasing pass - SIMPLIFIED FOR PERFORMANCE
            const fxaaPass = new ShaderPass(FXAAShader);
            fxaaPass.material.uniforms['resolution'].value.set(
                1 / (window.innerWidth * Math.min(window.devicePixelRatio, 1.5)),
                1 / (window.innerHeight * Math.min(window.devicePixelRatio, 1.5))
            );
            composer.addPass(fxaaPass);
        }

        // Create initial level components
        function createLevelOneComponents() {
            // Create power source (battery)
            createComponent(COMPONENT_POWER_SOURCE, 0, 2, DIRECTION_RIGHT, true, ENERGY_RED, false);

            // Create LED (lamp)
            createComponent(COMPONENT_LED, 4, 2, DIRECTION_RIGHT, false, ENERGY_RED, false);

            // Highlights connection pins on grid
            highlightConnectionPoints();
        }

        // Create component at grid position
        function createComponent(type, gridX, gridZ, direction, energized = false, energyType = ENERGY_RED, isPlacedByPlayer = true) {
            // Calculate world position from grid position
            const worldX = gridX - Math.floor(GRID_SIZE / 2);
            const worldZ = gridZ - Math.floor(GRID_SIZE / 2);

            // Create component group
            const group = new THREE.Group();
            group.position.set(worldX, 0, worldZ);

            // Store component data
            const componentData = {
                type: type,
                gridX: gridX,
                gridZ: gridZ,
                direction: direction,
                energized: energized,
                energyType: energyType,
                object3D: group,
                isPlacedByPlayer: isPlacedByPlayer
            };

            // Add component visuals based on type
            const baseColor = COMPONENT_COLORS[type];
            const glowColor = energized ? ENERGY_COLORS[energyType] : baseColor;

            // Common material properties
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: baseColor,
                metalness: 0.8,
                roughness: 0.2,
                emissive: baseColor,
                emissiveIntensity: 0.2
            });

            const glowMaterial = new THREE.MeshStandardMaterial({
                color: glowColor,
                metalness: 0.8,
                roughness: 0.2,
                emissive: glowColor,
                emissiveIntensity: energized ? 0.8 : 0.3
            });

            // Create 3D model based on component type
            switch (type) {
                case COMPONENT_POWER_SOURCE:
                    // Power source as a cube with a glowing sphere
                    const baseGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.8);
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 0.2;
                    base.castShadow = true;
                    base.receiveShadow = true;
                    group.add(base);

                    const coreGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const core = new THREE.Mesh(coreGeometry, glowMaterial);
                    core.position.y = 0.45;
                    group.add(core);

                    // Add output connector pin in facing direction with matching energy color
                    const outputColor = new THREE.Color(ENERGY_COLORS[energyType || ENERGY_RED]);
                    const outputGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 8);

                    // The whole group will be rotated based on component direction
                    const outputMaterial = new THREE.MeshStandardMaterial({
                        color: outputColor,
                        metalness: 0.9,
                        roughness: 0.2,
                        emissive: outputColor,
                        emissiveIntensity: 0.7
                    });

                    const outputPin = new THREE.Mesh(outputGeometry, outputMaterial);
                    // Always place at local +Z since group will be rotated
                    outputPin.position.set(0, 0.3, 0.4);
                    outputPin.rotation.x = Math.PI / 2; // Lay the pin flat
                    group.add(outputPin);

                    // Add a point light
                    if (energized) {
                        const light = new THREE.PointLight(
                            new THREE.Color(ENERGY_COLORS[energyType]),
                            1,
                            3
                        );
                        light.position.y = 0.45;
                        group.add(light);
                    }
                    break;

                case COMPONENT_WIRE:
                    // Wire as a tube
                    const wireGeometry = new THREE.CylinderGeometry(0.08, 0.08, CELL_SIZE, 8);

                    // Wire orientation
                    if (direction % 2 === 0) { // Vertical (UP/DOWN)
                        wireGeometry.rotateX(Math.PI / 2); // Rotate for vertical orientation
                    } else { // Horizontal (LEFT/RIGHT)
                        wireGeometry.rotateZ(Math.PI / 2); // Rotate for horizontal orientation
                    }
                    // Create translucent wire material
                    const wireMaterial = new THREE.MeshStandardMaterial({
                        color: glowColor,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: glowColor,
                        emissiveIntensity: energized ? 0.8 : 0.3,
                        transparent: true,         // Make it transparent
                        opacity: energized ? 0.8 : 0.6  // More translucent when not energized
                    });

                    const wire = new THREE.Mesh(wireGeometry, wireMaterial);
                    wire.position.y = 0.3;  // Position wire at same height as connection pins
                    group.add(wire);
                    break;


                case COMPONENT_LED:
                    // LED base as a cylinder
                    const ledBase = new THREE.CylinderGeometry(0.25, 0.25, 0.2, 16);
                    const ledBaseMesh = new THREE.Mesh(ledBase, baseMaterial);
                    ledBaseMesh.position.y = 0.1;
                    ledBaseMesh.castShadow = true;
                    ledBaseMesh.receiveShadow = true;
                    group.add(ledBaseMesh);

                    // LED top as a cone
                    const ledTop = new THREE.ConeGeometry(0.25, 0.3, 16);
                    ledTop.translate(0, 0.25, 0);
                    const ledTopMesh = new THREE.Mesh(ledTop, glowMaterial);
                    ledTopMesh.position.y = 0.2;
                    group.add(ledTopMesh);

                    // Add input pin matching the required energy type color
                    const pinColor = new THREE.Color(ENERGY_COLORS[energyType || ENERGY_RED]);

                    // Create pin cylinder
                    const pinGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.3, 8);

                    // Create pin material with the appropriate color
                    const pinMaterial = new THREE.MeshStandardMaterial({
                        color: pinColor,
                        metalness: 0.9,
                        roughness: 0.2,
                        emissive: pinColor,
                        emissiveIntensity: 0.5
                    });

                    const pinMesh = new THREE.Mesh(pinGeometry, pinMaterial);

                    // Position pin at the back of the LED (opposite to facing direction)
                    pinMesh.position.set(0, 0.3, -0.4);
                    pinMesh.rotation.x = Math.PI / 2; // Lay the pin flat
                    group.add(pinMesh);

                    // Add a point light if energized
                    if (energized) {
                        const light = new THREE.PointLight(
                            new THREE.Color(ENERGY_COLORS[energyType]),
                            1,
                            2
                        );
                        light.position.y = 0.5;
                        group.add(light);
                    }
                    break;
            }
            // Rotate the entire group based on direction
            if (type !== COMPONENT_WIRE) {
                group.rotation.y = direction * Math.PI / 2;
            }

            // Add to scene and component list
            scene.add(group);
            components.push(componentData);

            return componentData;
        }

        function setupIntuitiveTouch() {
            // Only add if touch is available
            if (!('ontouchstart' in window) &&
                !(navigator.maxTouchPoints > 0) &&
                !(navigator.msMaxTouchPoints > 0)) {
                return; // Not a touch device
            }

            console.log("Adding intuitive touch support for mobile devices");

            // Add mobile-friendly styles
            const mobileStyles = document.createElement('style');
            mobileStyles.textContent = `
        @media (max-width: 768px) {
            #level-info {
                top: auto;
                bottom: 110px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 90%;
            }
            
            #help-button {
                top: 20px;
                right: 10px;
            }
            
            .inventory-item {
                width: 70px;
                height: 70px;
            }
            
            button {
                min-height: 44px;
                min-width: 44px;
            }
        }
    `;
            document.head.appendChild(mobileStyles);

            // Add touch feedback element for long press
            const touchFeedback = document.createElement('div');
            touchFeedback.id = 'touch-feedback';
            touchFeedback.style.cssText = `
        position: absolute;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.8);
        pointer-events: none;
        opacity: 0;
        transform: translate(-50%, -50%);
        z-index: 1000;
        transition: opacity 0.1s ease, transform 0.2s ease, background-color 0.3s ease;
    `;
            document.body.appendChild(touchFeedback);

            // Add tiny tooltip to explain gestures (shown once)
            const touchTip = document.createElement('div');
            touchTip.id = 'touch-tip';
            touchTip.style.cssText = `
        position: absolute;
        bottom: 160px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(10, 10, 30, 0.85);
        border: 1px solid rgba(100, 100, 255, 0.7);
        border-radius: 10px;
        padding: 10px 15px;
        font-size: 12px;
        color: white;
        z-index: 100;
        text-align: center;
        max-width: 80%;
        opacity: 0;
        transition: opacity 0.5s ease;
    `;
            touchTip.innerHTML = `
        <strong>Touch Controls:</strong>
        <ul style="text-align: left; padding-left: 15px; margin: 5px 0;">
            <li>Tap empty space to place selected component</li>
            <li>Tap component to rotate it</li>
            <li>Long press component to remove it</li>
            <li>Double-tap component for quick removal</li>
        </ul>
        <div style="text-align: center; margin-top: 5px; font-size: 11px;">(Tap to dismiss)</div>
    `;
            document.body.appendChild(touchTip);

            // Show tooltip after a short delay (first time only)
            if (!localStorage.getItem('touchTipShown')) {
                setTimeout(() => {
                    touchTip.style.opacity = '1';
                    localStorage.setItem('touchTipShown', 'true');
                }, 1500);
            }

            // Touch event handlers for grid interaction
            renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Hide tooltip when tapped
            touchTip.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchTip.style.opacity = '0';
                setTimeout(() => touchTip.style.display = 'none', 500);
            });

            // Add touch support to UI buttons
            document.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    btn.click();
                });
            });

            // Add touch support to inventory items
            document.querySelectorAll('.inventory-item').forEach(item => {
                item.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    item.click();
                });
            });
        }

        // Touch start handler
        function handleTouchStart(e) {
            e.preventDefault();

            // Clear any existing long press timer
            if (longPressTimer) {
                clearTimeout(longPressTimer);
            }

            // Record start time for long press detection
            touchStartTime = Date.now();

            // Record touch position
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                touchStartPosition = {
                    x: touch.clientX,
                    y: touch.clientY
                };

                // Convert touch to grid coordinates
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

                // Show touch feedback
                const feedback = document.getElementById('touch-feedback');
                if (feedback) {
                    feedback.style.left = touch.clientX + 'px';
                    feedback.style.top = touch.clientY + 'px';
                    feedback.style.opacity = '1';
                    feedback.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                    feedback.style.transform = 'translate(-50%, -50%) scale(0.8)';
                }

                // Update raycaster
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(gridPlane);

                if (intersects.length > 0) {
                    // Get intersection point on grid
                    const point = intersects[0].point;

                    // Convert to grid coordinates
                    const gridX = Math.floor(point.x + GRID_SIZE / 2);
                    const gridZ = Math.floor(point.z + GRID_SIZE / 2);

                    // Check if within grid bounds
                    if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                        // Update hovered cell
                        hoveredCell = { x: gridX, y: gridZ };

                        // Highlight the hovered cell
                        highlightCell(gridX, gridZ);

                        // Check if there's a component at this position
                        const component = getComponentAt(gridX, gridZ);

                        // Set long press timer for removal if there's a component
                        if (component) {
                            longPressTimer = setTimeout(() => {
                                // Visual feedback
                                const feedback = document.getElementById('touch-feedback');
                                if (feedback) {
                                    feedback.style.backgroundColor = 'rgba(255, 60, 60, 0.5)';
                                    feedback.style.transform = 'translate(-50%, -50%) scale(1.3)';
                                }

                                // Haptic feedback if available
                                if (navigator.vibrate) {
                                    navigator.vibrate(100);
                                }

                                // Remove the component
                                removeComponentAt(gridX, gridZ);

                                // Reset long press timer
                                longPressTimer = null;
                            }, 800); // 800ms for long press
                        }
                    }
                }
            }
        }

        // Touch move handler
        function handleTouchMove(e) {
            e.preventDefault();

            // Cancel long press if movement is detected
            if (longPressTimer) {
                // Measure movement distance
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    const deltaX = Math.abs(touch.clientX - touchStartPosition.x);
                    const deltaY = Math.abs(touch.clientY - touchStartPosition.y);

                    // If moved more than 10 pixels, cancel long press
                    if (deltaX > 10 || deltaY > 10) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;

                        // Reset touch feedback
                        const feedback = document.getElementById('touch-feedback');
                        if (feedback) {
                            feedback.style.opacity = '0';
                        }
                    }
                }
            }

            if (e.touches.length === 0) return;

            // Convert touch to normalized device coordinates
            const touch = e.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            // Update raycaster and find intersections
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(gridPlane);

            if (intersects.length > 0) {
                // Get intersection point on grid
                const point = intersects[0].point;

                // Convert to grid coordinates
                const gridX = Math.floor(point.x + GRID_SIZE / 2);
                const gridZ = Math.floor(point.z + GRID_SIZE / 2);

                // Check if within grid bounds
                if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                    // Update hovered cell
                    hoveredCell = { x: gridX, y: gridZ };

                    // Highlight the hovered cell
                    highlightCell(gridX, gridZ);
                }
            }
        }

        // Touch end handler
        function handleTouchEnd(e) {
            e.preventDefault();

            // Clear long press timer
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }

            // Reset touch feedback
            const feedback = document.getElementById('touch-feedback');
            if (feedback) {
                feedback.style.opacity = '0';
            }

            // Only process if not touching UI elements
            const targetElement = e.target;
            if (targetElement.tagName === 'BUTTON' ||
                targetElement.classList.contains('inventory-item') ||
                targetElement !== renderer.domElement) {
                return;
            }

            // Get touch position
            const touch = e.changedTouches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            // Calculate touch duration
            const touchDuration = Date.now() - touchStartTime;
            const isLongPress = touchDuration > 800;

            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(gridPlane);

            if (intersects.length > 0) {
                // Get intersection point on grid
                const point = intersects[0].point;

                // Convert to grid coordinates
                const gridX = Math.floor(point.x + GRID_SIZE / 2);
                const gridZ = Math.floor(point.z + GRID_SIZE / 2);

                // Check if within grid bounds
                if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                    // Check if there's a component at this position
                    const component = getComponentAt(gridX, gridZ);

                    // Logic based on context:
                    // 1. Double tap = remove component
                    // 2. Tap on component = rotate it
                    // 3. Tap on empty cell with selection = place component

                    // Check for double tap (quick remove)
                    const now = Date.now();
                    const doubleTapDelay = 300; // ms

                    if (now - lastTapTime < doubleTapDelay && component) {
                        // Double tap on component - remove it
                        removeComponentAt(gridX, gridZ);
                        lastTapTime = 0; // Reset double-tap detection

                        // Haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate([20, 30, 20]);
                        }
                    }
                    else if (!isLongPress && component) {
                        // Single tap on component - rotate it
                        rotateComponentAt(gridX, gridZ);

                        // Haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate(30);
                        }

                        lastTapTime = now;
                    }
                    else if (!isLongPress && !component && selectedComponent) {
                        // Tap on empty cell with component selected - place it
                        if (selectedComponent === COMPONENT_WIRE) {
                            placeWire(gridX, gridZ);

                            // Haptic feedback if available
                            if (navigator.vibrate) {
                                navigator.vibrate(30);
                            }
                        }

                        lastTapTime = now;
                    }
                    // Long press is handled in the timeout callback
                }
            }
        }

        // Set up interactive grid
        function setupInteractiveGrid() {
            // Create a raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event listener for mouse movement
            window.addEventListener('mousemove', (event) => {
                // Update mouse position
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Cast ray
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(gridPlane);

                if (intersects.length > 0) {
                    // Get intersection point on grid
                    const point = intersects[0].point;

                    // Convert to grid coordinates
                    const gridX = Math.floor(point.x + GRID_SIZE / 2);
                    const gridZ = Math.floor(point.z + GRID_SIZE / 2);

                    // Check if within grid bounds
                    if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                        // Update hovered cell
                        hoveredCell = { x: gridX, y: gridZ };

                        // Highlight the hovered cell
                        highlightCell(gridX, gridZ);
                    }
                }
            });

            // Event listener for mouse click
            window.addEventListener('click', (event) => {
                // Ignore clicks on UI elements
                if (event.target !== renderer.domElement) return;

                // Cast ray
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(gridPlane);

                if (intersects.length > 0) {
                    // Get intersection point on grid
                    const point = intersects[0].point;

                    // Convert to grid coordinates
                    const gridX = Math.floor(point.x + GRID_SIZE / 2);
                    const gridZ = Math.floor(point.z + GRID_SIZE / 2);

                    // Check if within grid bounds
                    if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                        // Place component if one is selected
                        if (selectedComponent === COMPONENT_WIRE) {
                            placeWire(gridX, gridZ);
                        }
                    }
                }
            });

            // Event listener for right click (rotate)
            window.addEventListener('contextmenu', (event) => {
                event.preventDefault();

                // Cast ray
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(gridPlane);

                if (intersects.length > 0) {
                    // Get intersection point on grid
                    const point = intersects[0].point;

                    // Convert to grid coordinates
                    const gridX = Math.floor(point.x + GRID_SIZE / 2);
                    const gridZ = Math.floor(point.z + GRID_SIZE / 2);

                    // Check if within grid bounds
                    if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                        // Rotate component at this position
                        rotateComponentAt(gridX, gridZ);
                    }
                }
            });

            // Event listener for middle click or delete key (remove)
            window.addEventListener('auxclick', (event) => {
                if (event.button === 1) { // Middle mouse button
                    // Cast ray
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObject(gridPlane);

                    if (intersects.length > 0) {
                        // Get intersection point on grid
                        const point = intersects[0].point;

                        // Convert to grid coordinates
                        const gridX = Math.floor(point.x + GRID_SIZE / 2);
                        const gridZ = Math.floor(point.z + GRID_SIZE / 2);

                        // Check if within grid bounds
                        if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                            // Remove component at this position
                            removeComponentAt(gridX, gridZ);
                        }
                    }
                }
            });

            // Delete key for removing components
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Delete') {
                    // Cast ray
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObject(gridPlane);

                    if (intersects.length > 0) {
                        // Get intersection point on grid
                        const point = intersects[0].point;

                        // Convert to grid coordinates
                        const gridX = Math.floor(point.x + GRID_SIZE / 2);
                        const gridZ = Math.floor(point.z + GRID_SIZE / 2);

                        // Check if within grid bounds
                        if (gridX >= 0 && gridX < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                            // Remove component at this position
                            removeComponentAt(gridX, gridZ);
                        }
                    }
                }
            });
        }

        function highlightConnectionPoints() {
            // Remove any existing highlights
            scene.children.forEach(obj => {
                if (obj.name && obj.name.startsWith('ConnectionPoint')) {
                    scene.remove(obj);
                }
            });

            // Find all components that can be connected to
            components.forEach(component => {
                // Skip if it's a placed wire
                if (component.type === COMPONENT_WIRE && component.isPlacedByPlayer) return;

                const connectionPoints = [];

                // Determine which directions this component can connect from
                if (component.type === COMPONENT_POWER_SOURCE) {
                    // Power source connects in its facing direction
                    const dir = component.direction;
                    const offset = directionToOffset(dir);
                    connectionPoints.push({
                        x: component.gridX + offset.x,
                        z: component.gridZ + offset.y,
                        color: ENERGY_COLORS[component.energyType || ENERGY_RED]
                    });
                }
                else if (component.type === COMPONENT_LED) {
                    // LED connects from the opposite of its facing direction
                    const dir = (component.direction + 2) % 4; // Opposite direction
                    const offset = directionToOffset(dir);
                    connectionPoints.push({
                        x: component.gridX + offset.x,
                        z: component.gridZ + offset.y,
                        color: ENERGY_COLORS[component.energyType || ENERGY_RED]
                    });
                }

                // Create visual indicators for valid connection points
                connectionPoints.forEach(point => {
                    // Check if this point is within grid bounds
                    if (point.x >= 0 && point.x < GRID_SIZE && point.z >= 0 && point.z < GRID_SIZE) {
                        // Check if cell is empty
                        if (!getComponentAt(point.x, point.z)) {
                            // Create a subtle highlight
                            const geometry = new THREE.RingGeometry(0.25, 0.3, 16);
                            geometry.rotateX(Math.PI / 2); // Flat on ground

                            const material = new THREE.MeshBasicMaterial({
                                color: point.color,
                                transparent: true,
                                opacity: 0.3,
                                side: THREE.DoubleSide
                            });

                            const highlight = new THREE.Mesh(geometry, material);

                            // Position at grid cell
                            const worldX = point.x - Math.floor(GRID_SIZE / 2);
                            const worldZ = point.z - Math.floor(GRID_SIZE / 2);
                            highlight.position.set(worldX, 0.01, worldZ);

                            highlight.name = `ConnectionPoint_${point.x}_${point.z}`;
                            scene.add(highlight);

                            // Add pulsing animation
                            highlight.userData = {
                                originalOpacity: 0.3,
                                pulseFactor: Math.random() * Math.PI * 2 // Random phase
                            };
                        }
                    }
                });
            });
        }

        // Highlight a cell on the grid
        function highlightCell(gridX, gridZ) {
            // Remove any existing highlight
            const existingHighlight = scene.getObjectByName("GridHighlight");
            if (existingHighlight) {
                scene.remove(existingHighlight);
            }

            // Check if within grid bounds
            if (gridX < 0 || gridX >= GRID_SIZE || gridZ < 0 || gridZ >= GRID_SIZE) {
                return;
            }

            // Create a new highlight
            const highlightGeometry = new THREE.PlaneGeometry(0.98, 0.98); // Slightly smaller than cell
            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff, // Magenta
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });

            const highlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
            highlight.rotation.x = -Math.PI / 2; // Flat on XZ plane

            // Position at grid cell
            const worldX = gridX - Math.floor(GRID_SIZE / 2);
            const worldZ = gridZ - Math.floor(GRID_SIZE / 2);
            highlight.position.set(worldX, 0.02, worldZ); // Slightly above grid

            highlight.name = "GridHighlight";
            scene.add(highlight);

            // Add glowing outline around the highlight
            const edgesGeometry = new THREE.EdgesGeometry(highlightGeometry);
            const edgesMaterial = new THREE.LineBasicMaterial({
                color: 0xff00ff, // Magenta
                transparent: true,
                opacity: 0.6
            });

            const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
            edges.rotation.x = -Math.PI / 2; // Flat on XZ plane
            edges.position.set(worldX, 0.025, worldZ); // Just above the highlight
            edges.name = "GridHighlightEdges";
            scene.add(edges);

            // If we have a selected component, show preview while moving mouse over grid
            if (selectedComponent === COMPONENT_WIRE) {
                showComponentPreview(gridX, gridZ, COMPONENT_WIRE);
            }
        }

        // Show a preview of the component at grid position
        function showComponentPreview(gridX, gridZ, type) {
            // Remove any existing preview
            const existingPreview = scene.getObjectByName("ComponentPreview");
            if (existingPreview) {
                scene.remove(existingPreview);
            }

            // Check if cell is occupied
            if (getComponentAt(gridX, gridZ)) {
                return; // Don't show preview if cell is occupied
            }

            // Create preview based on component type
            const worldX = gridX - Math.floor(GRID_SIZE / 2);
            const worldZ = gridZ - Math.floor(GRID_SIZE / 2);

            let previewMesh;

            switch (type) {
                case COMPONENT_WIRE:
                    // Wire preview
                    const wireGeometry = new THREE.CylinderGeometry(0.08, 0.08, CELL_SIZE, 8);

                    const wireMaterial = new THREE.MeshBasicMaterial({
                        color: COMPONENT_COLORS[COMPONENT_WIRE],
                        transparent: true,
                        opacity: 0.4  // More translucent for preview
                    });

                    // Determine best direction automatically based on neighbors
                    const bestDirection = determineBestWireDirection(gridX, gridZ);


                    if (bestDirection % 2 === 0) { // Vertical (UP/DOWN)
                        wireGeometry.rotateX(Math.PI / 2);
                    } else { // Horizontal (LEFT/RIGHT)
                        wireGeometry.rotateZ(Math.PI / 2);
                    }

                    previewMesh = new THREE.Mesh(wireGeometry, wireMaterial);
                    previewMesh.position.y = 0.3;  // Position preview at same height as connection pins
                    break;
            }

            if (previewMesh) {
                // Create preview group
                const previewGroup = new THREE.Group();
                previewGroup.position.set(worldX, 0, worldZ);
                previewGroup.add(previewMesh);
                previewGroup.name = "ComponentPreview";

                // Store direction for later use
                const direction = determineBestWireDirection(gridX, gridZ);
                previewGroup.userData = { direction: direction };

                scene.add(previewGroup);
            }
        }

        // Determine the best direction for a wire based on neighboring components
        function determineBestWireDirection(gridX, gridZ) {
            // Check all four directions for components
            const neighbors = {
                [DIRECTION_UP]: getComponentAt(gridX, gridZ - 1),
                [DIRECTION_RIGHT]: getComponentAt(gridX + 1, gridZ),
                [DIRECTION_DOWN]: getComponentAt(gridX, gridZ + 1),
                [DIRECTION_LEFT]: getComponentAt(gridX - 1, gridZ)
            };

            // If there are components in both horizontal directions, use horizontal wire
            if (neighbors[DIRECTION_LEFT] && neighbors[DIRECTION_RIGHT]) {
                return DIRECTION_RIGHT; // Horizontal wire (DIRECTION_RIGHT indicates horizontal orientation)
            }

            // If there are components in both vertical directions, use vertical wire
            if (neighbors[DIRECTION_UP] && neighbors[DIRECTION_DOWN]) {
                return DIRECTION_UP; // Vertical wire (DIRECTION_UP indicates vertical orientation)
            }

            // If there's a component to the left or right, use horizontal wire
            if (neighbors[DIRECTION_LEFT] || neighbors[DIRECTION_RIGHT]) {
                return DIRECTION_RIGHT; // Horizontal wire
            }

            // If there's a component above or below, use vertical wire
            if (neighbors[DIRECTION_UP] || neighbors[DIRECTION_DOWN]) {
                return DIRECTION_UP; // Vertical wire
            }

            // Default: horizontal wire
            return DIRECTION_RIGHT;
        }

        // Place a wire at the grid position
        function placeWire(gridX, gridZ) {
            // Check if we have wires in inventory
            if (inventory[COMPONENT_WIRE] <= 0) {
                return; // Out of wires
            }

            // Check if cell is already occupied
            if (getComponentAt(gridX, gridZ)) {
                return; // Cell is occupied
            }

            // Get the preview direction if it exists
            let direction = DIRECTION_RIGHT; // Default
            const preview = scene.getObjectByName("ComponentPreview");
            if (preview && preview.userData && preview.userData.direction !== undefined) {
                direction = preview.userData.direction;
            } else {
                // Determine best direction based on neighbors
                direction = determineBestWireDirection(gridX, gridZ);
            }

            // Create wire component - the direction value determines the wire orientation
            createComponent(COMPONENT_WIRE, gridX, gridZ, direction, false, ENERGY_RED, true);

            // Decrease inventory
            inventory[COMPONENT_WIRE]--;
            updateInventoryDisplay();

            // Update energy flow
            calculateEnergyFlow();

            // Check if level is complete
            checkLevelComplete();

            // Highlights connection pins on grid
            highlightConnectionPoints();
        }

        // Rotate the component at a grid position
        function rotateComponentAt(gridX, gridZ) {
            console.log("Rotating component at", gridX, gridZ);

            // Find component at this position
            const component = getComponentAt(gridX, gridZ);

            if (component) {
                console.log("Found component:", component.type, "player placed:", component.isPlacedByPlayer);

                // Allow rotations of all components, not just player-placed ones
                if (component.type === COMPONENT_WIRE) {
                    // For wires, toggle between horizontal and vertical orientation
                    component.direction = (component.direction % 2 === 0) ? 1 : 0;

                    // Get the 3D object
                    const obj = component.object3D;

                    // Remove old wire mesh
                    while (obj.children.length > 0) {
                        obj.remove(obj.children[0]);
                    }

                    // Create new wire mesh with correct orientation
                    const wireGeometry = new THREE.CylinderGeometry(0.08, 0.08, CELL_SIZE, 8);

                    // Apply correct rotation based on new direction
                    if (component.direction % 2 === 0) { // Vertical
                        wireGeometry.rotateX(Math.PI / 2); // Match creation and preview rotations
                    } else { // Horizontal
                        wireGeometry.rotateZ(Math.PI / 2); // Match creation and preview rotations
                    }

                    // Get material based on energized state
                    const color = component.energized ?
                        ENERGY_COLORS[component.energyType] :
                        COMPONENT_COLORS[component.type];

                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: color,
                        emissiveIntensity: component.energized ? 0.8 : 0.3,
                        transparent: true,        // Make it transparent
                        opacity: component.energized ? 0.8 : 0.6  // More translucent when not energized
                    });

                    const wireMesh = new THREE.Mesh(wireGeometry, material);
                    
                    //Wire grid height
                    wireMesh.position.y = 0.3;

                    obj.add(wireMesh);
                } else {
                    // For other components, rotate direction and update 3D model rotation
                    component.direction = (component.direction + 1) % 4;
                    component.object3D.rotation.y = component.direction * Math.PI / 2;
                }

                // Update energy flow
                calculateEnergyFlow();

                // Check if level is complete
                checkLevelComplete();

                // Update connection highlights
                highlightConnectionPoints();
            }
        }

        // Remove a component at a grid position
        function removeComponentAt(gridX, gridZ) {
            // Find component at this position
            const component = getComponentAt(gridX, gridZ);

            if (component && component.isPlacedByPlayer) {
                // Remove from scene
                scene.remove(component.object3D);

                // Remove from components list
                const index = components.findIndex(c => c.gridX === gridX && c.gridZ === gridZ);
                if (index !== -1) {
                    components.splice(index, 1);
                }

                // Increase inventory
                inventory[component.type]++;
                updateInventoryDisplay();

                // Update energy flow
                calculateEnergyFlow();

                // Remove highlights from connection pins on grid
                highlightConnectionPoints();
            }
        }

        // Get component at grid position
        function getComponentAt(gridX, gridZ) {
            return components.find(component =>
                component.gridX === gridX &&
                component.gridZ === gridZ
            );
        }

        // Calculate energy flow through the circuit
        function calculateEnergyFlow() {
            console.log("Calculating energy flow...");

            // First, reset all components to non-energized state
            components.forEach(component => {
                if (component.type !== COMPONENT_POWER_SOURCE) { // Don't reset power sources
                    component.energized = false;

                    // Update visual appearance
                    updateComponentEnergizedState(component);
                }
            });

            // Clear existing energy paths
            clearEnergyPaths();

            // Find all power sources
            const powerSources = components.filter(c => c.type === COMPONENT_POWER_SOURCE);

            // Process energy flow from each source
            powerSources.forEach(source => {
                processEnergyFromSource(source);
            });

            // Create energy flow animations
            createEnergyFlowAnimations();

            // Debug info
            console.log("Energy flow calculation complete");
            const energizedCount = components.filter(c => c.energized).length;
            console.log(`Energized components: ${energizedCount}/${components.length}`);

            // Debug LEDs specifically
            const leds = components.filter(c => c.type === COMPONENT_LED);
            leds.forEach((led, i) => {
                console.log(`LED ${i + 1}: energized=${led.energized}`);
            });
        }


        // Process energy flow from a power source
        function processEnergyFromSource(source) {
            console.log(`Processing energy from source at (${source.gridX}, ${source.gridZ})`);

            // Get the direction the source is facing
            const direction = source.direction;

            // Get the neighboring cell in that direction
            const nextX = source.gridX + directionToOffset(direction).x;
            const nextZ = source.gridZ + directionToOffset(direction).y;

            // Check if there's a component there
            const nextComponent = getComponentAt(nextX, nextZ);
            if (nextComponent) {
                // Check if component can receive energy from this direction
                const oppositeDirection = (direction + 2) % 4;
                if (canAcceptEnergyFromDirection(nextComponent, oppositeDirection)) {
                    // Energize the component
                    energizeComponent(nextComponent, source.energyType);

                    // Add energy path
                    addEnergyPath(source.gridX, source.gridZ, nextX, nextZ, source.energyType);

                    // Continue energy flow
                    propagateEnergy(nextComponent);
                } else {
                    console.log(`Component at (${nextX}, ${nextZ}) cannot accept energy from direction ${oppositeDirection}`);
                }
            } else {
                console.log(`No component at (${nextX}, ${nextZ})`);
            }
        }

        // Propagate energy through a component
        function propagateEnergy(component) {
            console.log(`Propagating energy through ${component.type} at (${component.gridX}, ${component.gridZ})`);

            // Skip if component is a LED (end point)
            if (component.type === COMPONENT_LED) {
                console.log("LED reached - energy flow ends here");
                return;
            }

            // Get output directions based on component type and direction
            let outputDirections = [];

            if (component.type === COMPONENT_WIRE) {
                // Wire output depends on orientation
                if (component.direction % 2 === 0) { // Vertical (UP/DOWN)
                    outputDirections = [DIRECTION_UP, DIRECTION_DOWN];
                    console.log("Wire is vertical - can output UP or DOWN");
                } else { // Horizontal (LEFT/RIGHT)
                    outputDirections = [DIRECTION_LEFT, DIRECTION_RIGHT];
                    console.log("Wire is horizontal - can output LEFT or RIGHT");
                }
            } else if (component.type === COMPONENT_POWER_SOURCE) {
                // Power sources output in their facing direction
                outputDirections = [component.direction];
                console.log(`Power source outputs in direction ${component.direction}`);
            }

            // Process each output direction
            outputDirections.forEach(outDirection => {
                // Get the neighboring cell in that direction
                const nextX = component.gridX + directionToOffset(outDirection).x;
                const nextZ = component.gridZ + directionToOffset(outDirection).y;

                console.log(`Checking neighbor at (${nextX}, ${nextZ}) in direction ${outDirection}`);

                // Check if there's a component there
                const nextComponent = getComponentAt(nextX, nextZ);
                if (nextComponent) {
                    // Check if component can receive energy from this direction
                    const oppositeDirection = (outDirection + 2) % 4;

                    console.log(`Found ${nextComponent.type} with direction ${nextComponent.direction}`);
                    console.log(`Checking if it can accept energy from ${oppositeDirection}`);

                    const canAccept = canAcceptEnergyFromDirection(nextComponent, oppositeDirection);
                    console.log(`Can accept: ${canAccept}`);

                    if (canAccept) {
                        // Skip if already energized to prevent loops
                        if (!nextComponent.energized) {
                            // Energize the component
                            energizeComponent(nextComponent, component.energyType);

                            // Add energy path
                            addEnergyPath(component.gridX, component.gridZ, nextX, nextZ, component.energyType);

                            // Continue energy flow
                            propagateEnergy(nextComponent);
                        } else {
                            console.log("Component already energized - skipping to prevent loops");
                        }
                    }
                } else {
                    console.log("No component found in this direction");
                }
            });
        }

        function visualizeConnections() {
            // Remove existing debug visualizations
            scene.children.forEach(obj => {
                if (obj.name && obj.name.startsWith('DebugConnection')) {
                    scene.remove(obj);
                }
            });

            // Get all components
            components.forEach(component => {
                const worldX = component.gridX - Math.floor(GRID_SIZE / 2);
                const worldZ = component.gridZ - Math.floor(GRID_SIZE / 2);

                // Create a sphere at component location
                const sphereGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const sphereMaterial = new THREE.MeshBasicMaterial({
                    color: component.energized ? 0x00ff00 : 0xff0000
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(worldX, 0.5, worldZ);
                sphere.name = `DebugConnection_${component.gridX}_${component.gridZ}`;
                scene.add(sphere);

                // Add text label
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                context.font = '24px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.fillText(`${component.type}`, 128, 64);
                context.fillText(`Dir: ${component.direction}`, 128, 100);

                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                const label = new THREE.Sprite(labelMaterial);
                label.position.set(worldX, 1.0, worldZ);
                label.scale.set(1, 0.5, 1);
                label.name = `DebugConnection_${component.gridX}_${component.gridZ}_label`;
                scene.add(label);
            });
        }

        // Add a key listener for debug visualization (press 'D' to toggle)
        document.addEventListener('keydown', (event) => {
            if (event.key === 'd' || event.key === 'D') {
                visualizeConnections();
            }
        });

        // Check if a component can accept energy from a direction
        function canAcceptEnergyFromDirection(component, direction) {
            switch (component.type) {
                case COMPONENT_WIRE:
                    // Wires can accept energy from both ends of their orientation
                    if (component.direction % 2 === 0) { // Vertical (UP/DOWN)
                        return direction === DIRECTION_UP || direction === DIRECTION_DOWN;
                    } else { // Horizontal (LEFT/RIGHT)
                        return direction === DIRECTION_LEFT || direction === DIRECTION_RIGHT;
                    }

                case COMPONENT_LED:
                    // LEDs can only accept energy from the opposite of their facing direction
                    const oppositeOfLedDirection = (component.direction + 2) % 4;
                    console.log(`LED direction: ${component.direction}, opposite: ${oppositeOfLedDirection}, incoming: ${direction}`);
                    return direction === oppositeOfLedDirection;

                case COMPONENT_POWER_SOURCE:
                    // Power sources don't accept energy
                    return false;

                default:
                    return false;
            }
        }

        // Energize a component
        function energizeComponent(component, energyType) {
            console.log(`Energizing ${component.type} at (${component.gridX}, ${component.gridZ}) with ${energyType}`);

            component.energized = true;
            component.energyType = energyType;

            // Update visual appearance
            updateComponentEnergizedState(component);
        }

        // Update component visual state based on energized status
        function updateComponentEnergizedState(component) {
            // Get the 3D object
            const obj = component.object3D;

            // Update materials based on component type
            switch (component.type) {
                case COMPONENT_WIRE:
                    // Wire is just a single mesh
                    if (obj.children[0] && obj.children[0].material) {
                        const color = component.energized ?
                            ENERGY_COLORS[component.energyType] :
                            COMPONENT_COLORS[component.type];

                    // Update opacity based on energized state
                    if (obj.children[0].material.transparent) {
                        obj.children[0].material.opacity = component.energized ? 0.8 : 0.6;
                    }                            

                        obj.children[0].material.color.copy(color);
                        obj.children[0].material.emissive.copy(color);
                        obj.children[0].material.emissiveIntensity = component.energized ? 3.0 : 0.1;
                    }
                    
                    // Add/remove point light based on energized state
                    if (component.energized) {
                        // Check if light already exists
                        let hasLight = false;
                        obj.children.forEach(child => {
                            if (child.type === 'PointLight') hasLight = true;
                        });

                        if (!hasLight) {
                            const light = new THREE.PointLight(
                                new THREE.Color(ENERGY_COLORS[component.energyType]),
                                0.8,  // Increased intensity
                                1.2   // Increased distance
                            );
                            light.position.y = 0.2;
                            obj.add(light);
                        }
                    } else {
                        // Remove any existing lights
                        obj.children.forEach(child => {
                            if (child.type === 'PointLight') obj.remove(child);
                        });
                    }
                    break;

                case COMPONENT_LED:
                    // LED has base and top
                    if (obj.children[1] && obj.children[1].material) {
                        const color = component.energized ?
                            ENERGY_COLORS[component.energyType] :
                            COMPONENT_COLORS[component.type];

                        obj.children[1].material.color.copy(color);
                        obj.children[1].material.emissive.copy(color);
                        obj.children[1].material.emissiveIntensity = component.energized ? 1.5 : 0.1;
                    }

                    // Add/remove point light based on energized state
                    if (component.energized) {
                        // Check if light already exists
                        let hasLight = false;
                        obj.children.forEach(child => {
                            if (child.type === 'PointLight') hasLight = true;
                        });

                        if (!hasLight) {
                            const light = new THREE.PointLight(
                                new THREE.Color(ENERGY_COLORS[component.energyType]),
                                2.0,  // Much brighter
                                3.5   // Larger radius
                            );
                            light.position.y = 0.5;
                            obj.add(light);
                        }
                    } else {
                        // Remove any existing lights
                        obj.children.forEach(child => {
                            if (child.type === 'PointLight') obj.remove(child);
                        });
                    }
                    break;
                    
                case COMPONENT_POWER_SOURCE:
                    // Power source updates
                    if (component.energized && obj.children.length > 1) {
                        // Update core sphere to be brighter
                        if (obj.children[1] && obj.children[1].material) {
                            obj.children[1].material.emissiveIntensity = 1.2;
                        }
                        
                        // Add/update point light
                        let hasLight = false;
                        obj.children.forEach(child => {
                            if (child.type === 'PointLight') {
                                hasLight = true;
                                child.intensity = 1.5;
                                child.distance = 2.5;
                            }
                        });
                        
                        if (!hasLight) {
                            const light = new THREE.PointLight(
                                new THREE.Color(ENERGY_COLORS[component.energyType]),
                                1.5,
                                2.5
                            );
                            light.position.y = 0.45;
                            obj.add(light);
                        }
                    }
                    break;
            }
        }

        // Convert direction to grid offset
        function directionToOffset(direction) {
            switch (direction) {
                case DIRECTION_UP: return { x: 0, y: -1 }; // Up is -Z
                case DIRECTION_RIGHT: return { x: 1, y: 0 }; // Right is +X
                case DIRECTION_DOWN: return { x: 0, y: 1 }; // Down is +Z
                case DIRECTION_LEFT: return { x: -1, y: 0 }; // Left is -X
                default: return { x: 0, y: 0 };
            }
        }

        // Add an energy path between two cells
        function addEnergyPath(x1, z1, x2, z2, energyType) {
            energyPaths.push({
                x1: x1,
                z1: z1,
                x2: x2,
                z2: z2,
                energyType: energyType
            });
        }

        // Clear all energy paths
        function clearEnergyPaths() {
            energyPaths = [];

            // Clear existing particle animations
            energyParticles.forEach(particle => {
                if (particle.object) {
                    scene.remove(particle.object);
                }
            });

            energyParticles = [];
        }

        // Create energy flow animations
        function createEnergyFlowAnimations() {
            // Clear existing particle animations
            energyParticles.forEach(particle => {
                // Update position based on progress
                const { x1, z1, x2, z2 } = particle.path;
                const progress = particle.progress;

                // Interpolate position
                particle.object.position.x = x1 + (x2 - x1) * progress;
                particle.object.position.z = z1 + (z2 - z1) * progress;
                // CHANGE THIS LINE:
                particle.object.position.y = 0.3;  // Exactly match wire height
            });

            energyParticles = [];

            // For each energy path, create flowing particles
            energyPaths.forEach(path => {
                const color = ENERGY_COLORS[path.energyType];

                // Calculate world positions
                const x1 = path.x1 - Math.floor(GRID_SIZE / 2);
                const z1 = path.z1 - Math.floor(GRID_SIZE / 2);
                const x2 = path.x2 - Math.floor(GRID_SIZE / 2);
                const z2 = path.z2 - Math.floor(GRID_SIZE / 2);

                // Create only 2 larger particles for better performance and visibility
                for (let i = 0; i < 2; i++) {
                    // Create particle geometry - LARGER SIZE, LOWER POLY
                    const particleGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1.0  // Full opacity for better visibility
                    });

                    const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);

                    // Initial position (starting point of path)
                    particleMesh.position.set(x1, 0.3, z1);

                    // Add BRIGHTER point light
                    const light = new THREE.PointLight(color, 0.8, 1.0);
                    particleMesh.add(light);

                    scene.add(particleMesh);

                    // Store particle data
                    energyParticles.push({
                        object: particleMesh,
                        path: { x1, z1, x2, z2 },
                        progress: i * 0.5, // Stagger particles
                        speed: 0.015 + Math.random() * 0.005 // SLOWER for better visibility
                    });
                }
            });
        }

        // Update inventory display
        function updateInventoryDisplay() {
            document.querySelector('.inventory-item[data-component="wire"] .inventory-count').textContent =
                inventory[COMPONENT_WIRE].toString();
        }

        // Check if level is complete
        function checkLevelComplete() {
            if (isLevelComplete) return; // Already completed

            console.log("Checking if level is complete...");

            // Level 1 is complete when the LED is energized
            const leds = components.filter(c => c.type === COMPONENT_LED);

            console.log(`Found ${leds.length} LEDs on the level`);

            if (leds.length > 0) {
                const allLit = leds.every(led => led.energized);
                console.log(`All LEDs energized: ${allLit}`);

                if (allLit) {
                    console.log("LEVEL COMPLETE!");
                    isLevelComplete = true;

                    // Start celebration effects
                    celebrate();
                }
            }
        }

        // Victory Particle System
        class ParticleSystem {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
                this.maxParticles = 50;
            }

            createParticle(position, color, size, velocity, lifetime, gravityEffect = 0) {
                const geometry = new THREE.SphereGeometry(size, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1.0
                });

                const particle = new THREE.Mesh(geometry, material);

                // Add a point light to some particles for extra glow
                if (Math.random() > 0.7) {
                    const light = new THREE.PointLight(color, 0.5, 2);
                    particle.add(light);
                }

                particle.position.copy(position);

                // Store particle properties
                particle.userData = {
                    velocity: velocity,
                    lifetime: lifetime,
                    age: 0,
                    gravityEffect: gravityEffect,
                    initialSize: size
                };

                this.scene.add(particle);
                this.particles.push(particle);

                // Remove oldest particles if we exceed the maximum
                if (this.particles.length > this.maxParticles) {
                    const oldParticle = this.particles.shift();
                    this.scene.remove(oldParticle);
                }

                return particle;
            }

            update(deltaTime) {
                const particlesToRemove = [];

                // Update each particle
                this.particles.forEach(particle => {
                    const userData = particle.userData;

                    // Update age
                    userData.age += deltaTime;

                    // Update position based on velocity
                    particle.position.x += userData.velocity.x * deltaTime;
                    particle.position.y += userData.velocity.y * deltaTime;
                    particle.position.z += userData.velocity.z * deltaTime;

                    // Apply gravity effect if specified
                    if (userData.gravityEffect > 0) {
                        userData.velocity.y -= userData.gravityEffect * deltaTime;
                    }

                    // Calculate lifetime ratio (0 to 1)
                    const lifeRatio = userData.age / userData.lifetime;

                    // Fade out based on lifetime
                    if (lifeRatio < 0.7) {
                        // First 70% maintain full opacity
                        particle.material.opacity = 1.0;
                    } else {
                        // Last 30% fade out
                        particle.material.opacity = 1.0 - ((lifeRatio - 0.7) / 0.3);
                    }

                    // Scale down slightly over time
                    const scaleRatio = 1.0 - (lifeRatio * 0.3);
                    particle.scale.set(scaleRatio, scaleRatio, scaleRatio);

                    // Mark for removal if lifetime is exceeded
                    if (userData.age >= userData.lifetime) {
                        particlesToRemove.push(particle);
                    }
                });

                // Remove expired particles
                particlesToRemove.forEach(particle => {
                    const index = this.particles.indexOf(particle);
                    if (index !== -1) {
                        this.particles.splice(index, 1);
                    }
                    this.scene.remove(particle);
                });
            }

            clear() {
                // Remove all particles
                this.particles.forEach(particle => {
                    this.scene.remove(particle);
                });
                this.particles = [];
            }
        }

        // Enhanced celebration function
        function celebrate() {
            console.log("CELEBRATION STARTING!");

            // Create particle system if it doesn't exist
            if (!window.victoryParticles) {
                window.victoryParticles = new ParticleSystem(scene);
            }

            // Find all LEDs for celebration effects
            const leds = components.filter(c => c.type === COMPONENT_LED);

            // Make LEDs pulse more intensely
            leds.forEach(led => {
                const obj = led.object3D;

                // Increase light intensity on LEDs
                obj.children.forEach(child => {
                    if (child.type === 'PointLight') {
                        child.intensity = 3;
                        child.distance = 8;

                        // Animate intensity over time
                        const originalIntensity = child.intensity;

                        // Create a pulse animation
                        const pulseAnimation = setInterval(() => {
                            child.intensity = originalIntensity * (1 + Math.random() * 0.5);
                        }, 100);

                        // Clear animation after celebration
                        setTimeout(() => {
                            clearInterval(pulseAnimation);
                            child.intensity = 2;
                            child.distance = 5;
                        }, 5000);
                    }
                });
            });

            // Play sound effects with slight delay between them
            setTimeout(() => {
                victoryAudio.winSound.play();
            }, 200);

            setTimeout(() => {
                victoryAudio.successJingle.play();
            }, 800);

            // Create a central explosion effect
            createExplosionEffect();

            // Create circuit completion effect
            createCircuitCompletionEffect();

            // Flash screen briefly
            flashScreen();

            // Show level complete message after celebration effects
            setTimeout(() => {
                document.getElementById('level-complete').style.display = 'block';
            }, 3000);
        }

        // Create an explosion effect at each LED
        function createExplosionEffect() {
            // Find all LEDs
            const leds = components.filter(c => c.type === COMPONENT_LED);

            // Create explosion at each LED
            leds.forEach(led => {
                const position = led.object3D.position.clone();
                position.y += 0.5; // Lift explosion slightly above LED

                // Color based on LED energy type
                const color = new THREE.Color(ENERGY_COLORS[led.energyType]);

                // Create initial flash
                const flashGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });

                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(position);
                scene.add(flash);

                // Animate flash
                let scale = 1.0;
                const flashAnimation = setInterval(() => {
                    scale += 0.2;
                    flash.scale.set(scale, scale, scale);
                    flash.material.opacity = Math.max(0, 0.8 - ((scale - 1) * 0.2));
                }, 50);

                // Remove flash after animation
                setTimeout(() => {
                    clearInterval(flashAnimation);
                    scene.remove(flash);
                }, 1000);

                // Create intense point light at explosion center
                const explosionLight = new THREE.PointLight(color, 5, 10);
                explosionLight.position.copy(position);
                scene.add(explosionLight);

                // Animate light intensity
                let intensity = 5;
                const lightAnimation = setInterval(() => {
                    intensity -= 0.2;
                    explosionLight.intensity = Math.max(0, intensity);
                }, 100);

                // Remove light after animation
                setTimeout(() => {
                    clearInterval(lightAnimation);
                    scene.remove(explosionLight);
                }, 2500);

                // Create particle burst
                for (let i = 0; i < 50; i++) {
                    // Random direction
                    const angle = Math.random() * Math.PI * 2;
                    const z = Math.random() * 2 - 1; // -1 to 1
                    const planarMagnitude = Math.sqrt(1 - z * z);

                    const dir = new THREE.Vector3(
                        planarMagnitude * Math.cos(angle),
                        planarMagnitude * Math.sin(angle),
                        z
                    );

                    // Random speed
                    const speed = 0.5 + Math.random() * 2.5;

                    // Velocity
                    const velocity = new THREE.Vector3(
                        dir.x * speed,
                        dir.y * speed,
                        dir.z * speed
                    );

                    // Random size
                    const size = 0.05 + Math.random() * 0.15;

                    // Random lifetime
                    const lifetime = 1.0 + Math.random() * 2.0;

                    // Random color variations
                    const colorVariation = new THREE.Color(
                        color.r * (0.8 + Math.random() * 0.4),
                        color.g * (0.8 + Math.random() * 0.4),
                        color.b * (0.8 + Math.random() * 0.4)
                    );

                    // Create particle with slight gravity
                    victoryParticles.createParticle(
                        position,
                        colorVariation,
                        size,
                        velocity,
                        lifetime,
                        0.5 // Gravity effect
                    );
                }
            });
        }

        // Create a circuit completion effect that travels along the energy paths
        function createCircuitCompletionEffect() {
			
            // Create particles that follow energy paths
            energyPaths.forEach(path => {
                // Calculate world positions
                const x1 = path.x1 - Math.floor(GRID_SIZE / 2);
                const z1 = path.z1 - Math.floor(GRID_SIZE / 2);
                const x2 = path.x2 - Math.floor(GRID_SIZE / 2);
                const z2 = path.z2 - Math.floor(GRID_SIZE / 2);

                const color = ENERGY_COLORS[path.energyType];

                // Create multiple waves of particles along each path
                for (let wave = 0; wave < 3; wave++) {
                    setTimeout(() => {
                        // Create several particles for each wave
                        for (let i = 0; i < 15; i++) {
                            // Random position along the path
                            const t = Math.random();
                            const pos = new THREE.Vector3(
                                x1 + (x2 - x1) * t,
                                0.2, // Slightly above the grid
                                z1 + (z2 - z1) * t
                            );

                            // Random vertical velocity
                            const velocity = new THREE.Vector3(
                                0,
                                0.5 + Math.random() * 1.0,
                                0
                            );

                            // Random size
                            const size = 0.1 + Math.random() * 0.1;

                            // Random lifetime
                            const lifetime = 1.0 + Math.random() * 1.5;

                            // Create rising particle
                            victoryParticles.createParticle(
                                pos,
                                color,
                                size,
                                velocity,
                                lifetime,
                                -0.1 // Negative gravity (rises faster over time)
                            );
                        }
                    }, wave * 300); // Stagger the waves
                }
            });
        }

        // Flash the screen briefly for dramatic effect
        function flashScreen() {
            // Create a full-screen flash effect
            const flashOverlay = document.createElement('div');
            flashOverlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: white;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.1s ease-out;
    z-index: 1000;
  `;

            document.body.appendChild(flashOverlay);

            // Flash in
            setTimeout(() => {
                flashOverlay.style.opacity = '0.8';
            }, 100);

            // Flash out
            setTimeout(() => {
                flashOverlay.style.opacity = '0';
            }, 250);

            // Remove after animation
            setTimeout(() => {
                document.body.removeChild(flashOverlay);
            }, 1000);
        }

        // Update the animation loop to include particle system updates
        const originalAnimate = animate;
        window.animate = function () {
            // Call original animation function
            originalAnimate();

            // Update particle system if it exists
            if (window.victoryParticles) {
                const deltaTime = 0.016; // Approximately 60fps
                victoryParticles.update(deltaTime);
            }
        };

        // Set up UI event listeners
        function setupEventListeners() {
            // Touch input support
            setupIntuitiveTouch();
            
            // Make all dialogs dismissible with a click
            document.getElementById('level-info').addEventListener('click', function() {
                this.style.display = 'none';
            });
            
            // Make tutorial dismissible by clicking anywhere
            document.getElementById('tutorial').addEventListener('click', function(e) {
                if (e.target !== document.getElementById('close-tutorial')) {
                    this.style.display = 'none';
                }
            });
            
            // Make level-complete dismissible by clicking anywhere
            document.getElementById('level-complete').addEventListener('click', function(e) {
                if (e.target !== document.getElementById('next-level')) {
                    this.style.display = 'none';
                }
            });
            
            // Auto-hide level info after 8 seconds
            setTimeout(() => {
                const levelInfo = document.getElementById('level-info');
                if (levelInfo.style.display !== 'none') {
                    levelInfo.style.display = 'none';
                }
            }, 8000);
            
            // Inventory item selection
            document.querySelectorAll('.inventory-item').forEach(item => {
                item.addEventListener('click', () => {
                    // Get component type
                    const componentType = item.getAttribute('data-component');
                    // If we have this component in inventory
                    if (inventory[componentType] > 0) {
                        // Toggle selection
                        if (selectedComponent === componentType) {
                            selectedComponent = null;
                            item.classList.remove('selected');
                        } else {
                            // Deselect any previously selected items
                            document.querySelectorAll('.inventory-item').forEach(i => {
                                i.classList.remove('selected');
                            });
                            selectedComponent = componentType;
                            item.classList.add('selected');
                        }
                    }
                });
            });
            
            // Help button
            document.getElementById('help-button').addEventListener('click', () => {
                document.getElementById('tutorial').style.display = 'block';
            });
            
            // Close tutorial button
            document.getElementById('close-tutorial').addEventListener('click', (e) => {
                document.getElementById('tutorial').style.display = 'none';
                e.stopPropagation(); // Prevent the tutorial click handler from firing
            });
            
            // Next level button
            document.getElementById('next-level').addEventListener('click', (e) => {
                // For now, just reload the page
                window.location.reload();
                // ToDo: load the next level
                e.stopPropagation(); // Prevent the level-complete click handler from firing
            });
            
            // Window resize handling
            window.addEventListener('resize', () => {
                // Update camera aspect ratio
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                // Update renderer size
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                // Update FXAA pass resolution
                composer.passes[2].material.uniforms['resolution'].value.set(
                    1 / (window.innerWidth * renderer.getPixelRatio()),
                    1 / (window.innerHeight * renderer.getPixelRatio())
                );
            });
        }

        function setupTouchSupport() {
            // Only add if touch is available
            if (!('ontouchstart' in window) &&
                !(navigator.maxTouchPoints > 0) &&
                !(navigator.msMaxTouchPoints > 0)) {
                return; // Not a touch device
            }

            console.log("Adding touch support for mobile devices");

            // Create touch mode UI
            touchModeUI = document.createElement('div');
            touchModeUI.id = 'touch-mode-ui';
            touchModeUI.style.cssText = `
        position: absolute;
        bottom: 90px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(10, 10, 30, 0.7);
        border: 1px solid rgba(60, 60, 255, 0.5);
        border-radius: 10px;
        padding: 5px;
        z-index: 100;
        display: flex;
        gap: 5px;
    `;

            // Create mode buttons
            const modes = [
                { name: 'place', label: 'Place', color: 'rgba(60, 120, 255, 0.6)' },
                { name: 'rotate', label: 'Rotate', color: 'rgba(255, 120, 60, 0.6)' },
                { name: 'remove', label: 'Remove', color: 'rgba(255, 60, 60, 0.6)' }
            ];

            const buttons = {};

            modes.forEach(mode => {
                const button = document.createElement('button');
                button.textContent = mode.label;
                button.dataset.mode = mode.name;
                button.style.cssText = `
            background-color: ${mode.name === 'place' ? mode.color : 'rgba(30, 30, 60, 0.8)'};
            color: white;
            border: 2px solid ${mode.color};
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        `;

                button.addEventListener('click', () => {
                    // Update active mode
                    currentTouchMode = mode.name;

                    // Update all button appearances
                    modes.forEach(m => {
                        const btn = buttons[m.name];
                        btn.style.backgroundColor = m.name === currentTouchMode ? m.color : 'rgba(30, 30, 60, 0.8)';
                    });

                    // Optional: Add haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                });

                buttons[mode.name] = button;
                touchModeUI.appendChild(button);
            });

            document.body.appendChild(touchModeUI);

            // Touch event handlers for grid interaction
            renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Add touch support to UI buttons
            document.querySelectorAll('button').forEach(btn => {
                if (btn.id !== 'touch-mode-ui') { // Skip the mode buttons we just created
                    btn.addEventListener('touchend', e => {
                        e.preventDefault();
                        btn.click();
                    });
                }
            });

            // Add touch support to inventory items
            document.querySelectorAll('.inventory-item').forEach(item => {
                item.addEventListener('touchend', e => {
                    e.preventDefault();
                    item.click();
                });
            });

            // Add mobile-friendly styles
            const mobileStyles = document.createElement('style');
            mobileStyles.textContent = `
        @media (max-width: 768px) {
            #level-info {
                top: auto;
                bottom: 160px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 90%;
            }
            
            #help-button {
                top: 10px;
                right: 10px;
            }
            
            .inventory-item {
                width: 70px;
                height: 70px;
            }
            
            button {
                min-height: 44px;
                min-width: 44px;
            }
        }
    `;
            document.head.appendChild(mobileStyles);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update controls
            controls.update();

            // Update energy particles - LIMIT UPDATES for performance
            for (let i = 0; i < Math.min(energyParticles.length, 6); i++) {
                const particle = energyParticles[i];
                
                // Update position based on progress
                const { x1, z1, x2, z2 } = particle.path;
                const progress = particle.progress;

                // Interpolate position
                particle.object.position.x = x1 + (x2 - x1) * progress;
                particle.object.position.z = z1 + (z2 - z1) * progress;

                // Update progress
                particle.progress += particle.speed;
                if (particle.progress > 1) {
                    particle.progress = 0;
                }

                // Pulse size and opacity - LESS FREQUENT changes
                const time = Date.now();
                if (time % 30 === 0) { // Only update every ~30ms
                    const pulse = 0.9 + 0.1 * Math.sin(time * 0.005);
                    particle.object.scale.set(pulse * 1.5, pulse * 1.5, pulse * 1.5);
                }
            }

            // Update connection point animations - LESS FREQUENT updates
            if (Date.now() % 2 == 0) { // Update ~20% of the time
                scene.children.forEach(obj => {
                    if (obj.name && obj.name.startsWith('ConnectionPoint') && obj.userData) {
                        const { originalOpacity, pulseFactor } = obj.userData;
                        
                        // Pulse opacity based on time
                        const pulse = Math.sin(Date.now() * 0.002 + pulseFactor) * 0.3 + 0.7;
                        obj.material.opacity = originalOpacity * pulse;
                    }
                });
            }

            // Update component animations - LESS FREQUENT updates
            if (Date.now() % 2 == 0) { // Update ~16% of the time
                components.forEach(component => {
                    if (component.energized) {
                        const obj = component.object3D;
                        
                        obj.children.forEach(child => {
                            if (child.material && child.material.emissiveIntensity) {
                                // Pulse emissive intensity
                                child.material.emissiveIntensity = 0.8 + 0.3 * Math.sin(Date.now() * 0.002);
                            }
                        });
                    }
                });
            }

            // Render with post-processing
            composer.render();
        }



    </script>
</body>

</html>